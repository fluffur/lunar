// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: friends.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createBlock = `-- name: CreateBlock :exec
INSERT INTO user_blocks (from_user_id, to_user_id)
VALUES ($1, $2)
`

type CreateBlockParams struct {
	FromUserID uuid.UUID `db:"from_user_id" json:"fromUserId"`
	ToUserID   uuid.UUID `db:"to_user_id" json:"toUserId"`
}

func (q *Queries) CreateBlock(ctx context.Context, arg CreateBlockParams) error {
	_, err := q.db.Exec(ctx, createBlock, arg.FromUserID, arg.ToUserID)
	return err
}

const createFriendRequest = `-- name: CreateFriendRequest :exec
INSERT INTO friend_requests (from_user_id, to_user_id, message)
VALUES ($1, $2, $3)
`

type CreateFriendRequestParams struct {
	FromUserID uuid.UUID `db:"from_user_id" json:"fromUserId"`
	ToUserID   uuid.UUID `db:"to_user_id" json:"toUserId"`
	Message    string    `db:"message" json:"message"`
}

func (q *Queries) CreateFriendRequest(ctx context.Context, arg CreateFriendRequestParams) error {
	_, err := q.db.Exec(ctx, createFriendRequest, arg.FromUserID, arg.ToUserID, arg.Message)
	return err
}

const deleteBlock = `-- name: DeleteBlock :exec
DELETE FROM user_blocks
WHERE from_user_id = $1 AND to_user_id = $2
`

type DeleteBlockParams struct {
	FromUserID uuid.UUID `db:"from_user_id" json:"fromUserId"`
	ToUserID   uuid.UUID `db:"to_user_id" json:"toUserId"`
}

func (q *Queries) DeleteBlock(ctx context.Context, arg DeleteBlockParams) error {
	_, err := q.db.Exec(ctx, deleteBlock, arg.FromUserID, arg.ToUserID)
	return err
}

const deleteFriendRequest = `-- name: DeleteFriendRequest :exec
DELETE FROM friend_requests
WHERE from_user_id = $1 AND to_user_id = $2
`

type DeleteFriendRequestParams struct {
	FromUserID uuid.UUID `db:"from_user_id" json:"fromUserId"`
	ToUserID   uuid.UUID `db:"to_user_id" json:"toUserId"`
}

func (q *Queries) DeleteFriendRequest(ctx context.Context, arg DeleteFriendRequestParams) error {
	_, err := q.db.Exec(ctx, deleteFriendRequest, arg.FromUserID, arg.ToUserID)
	return err
}

const deleteFriendshipEdge = `-- name: DeleteFriendshipEdge :exec
DELETE FROM friendships
WHERE user_id = $1 AND friend_id = $2
`

type DeleteFriendshipEdgeParams struct {
	UserID   uuid.UUID `db:"user_id" json:"userId"`
	FriendID uuid.UUID `db:"friend_id" json:"friendId"`
}

func (q *Queries) DeleteFriendshipEdge(ctx context.Context, arg DeleteFriendshipEdgeParams) error {
	_, err := q.db.Exec(ctx, deleteFriendshipEdge, arg.UserID, arg.FriendID)
	return err
}

const getFriendRequest = `-- name: GetFriendRequest :one
SELECT from_user_id, to_user_id, status, message, created_at, responded_at
FROM friend_requests
WHERE from_user_id = $1 AND to_user_id = $2
`

type GetFriendRequestParams struct {
	FromUserID uuid.UUID `db:"from_user_id" json:"fromUserId"`
	ToUserID   uuid.UUID `db:"to_user_id" json:"toUserId"`
}

func (q *Queries) GetFriendRequest(ctx context.Context, arg GetFriendRequestParams) (FriendRequest, error) {
	row := q.db.QueryRow(ctx, getFriendRequest, arg.FromUserID, arg.ToUserID)
	var i FriendRequest
	err := row.Scan(
		&i.FromUserID,
		&i.ToUserID,
		&i.Status,
		&i.Message,
		&i.CreatedAt,
		&i.RespondedAt,
	)
	return i, err
}

const insertFriendshipEdge = `-- name: InsertFriendshipEdge :exec
INSERT INTO friendships (user_id, friend_id, created_at)
VALUES ($1, $2, now())
`

type InsertFriendshipEdgeParams struct {
	UserID   uuid.UUID `db:"user_id" json:"userId"`
	FriendID uuid.UUID `db:"friend_id" json:"friendId"`
}

func (q *Queries) InsertFriendshipEdge(ctx context.Context, arg InsertFriendshipEdgeParams) error {
	_, err := q.db.Exec(ctx, insertFriendshipEdge, arg.UserID, arg.FriendID)
	return err
}

const isBlocked = `-- name: IsBlocked :one
SELECT EXISTS(
    SELECT 1 FROM user_blocks
    WHERE from_user_id = $1 AND to_user_id = $2
) AS blocked
`

type IsBlockedParams struct {
	FromUserID uuid.UUID `db:"from_user_id" json:"fromUserId"`
	ToUserID   uuid.UUID `db:"to_user_id" json:"toUserId"`
}

func (q *Queries) IsBlocked(ctx context.Context, arg IsBlockedParams) (bool, error) {
	row := q.db.QueryRow(ctx, isBlocked, arg.FromUserID, arg.ToUserID)
	var blocked bool
	err := row.Scan(&blocked)
	return blocked, err
}

const listBlocked = `-- name: ListBlocked :many
SELECT from_user_id, to_user_id, created_at
FROM user_blocks
WHERE from_user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListBlocked(ctx context.Context, fromUserID uuid.UUID) ([]UserBlock, error) {
	rows, err := q.db.Query(ctx, listBlocked, fromUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserBlock{}
	for rows.Next() {
		var i UserBlock
		if err := rows.Scan(&i.FromUserID, &i.ToUserID, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFriends = `-- name: ListFriends :many
SELECT user_id, friend_id, created_at
FROM friendships
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListFriends(ctx context.Context, userID uuid.UUID) ([]Friendship, error) {
	rows, err := q.db.Query(ctx, listFriends, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Friendship{}
	for rows.Next() {
		var i Friendship
		if err := rows.Scan(&i.UserID, &i.FriendID, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFriendsWithUsers = `-- name: ListFriendsWithUsers :many
SELECT 
    f.user_id,
    f.friend_id,
    f.created_at,
    u.id as friend_user_id,
    u.username as friend_username,
    u.avatar_url as friend_avatar_url
FROM friendships f
INNER JOIN users u ON u.id = f.friend_id
WHERE f.user_id = $1
ORDER BY f.created_at DESC
`

type ListFriendsWithUsersRow struct {
	UserID          uuid.UUID          `db:"user_id" json:"userId"`
	FriendID        uuid.UUID          `db:"friend_id" json:"friendId"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"createdAt"`
	FriendUserID    uuid.UUID          `db:"friend_user_id" json:"friendUserId"`
	FriendUsername  string             `db:"friend_username" json:"friendUsername"`
	FriendAvatarUrl pgtype.Text        `db:"friend_avatar_url" json:"friendAvatarUrl"`
}

func (q *Queries) ListFriendsWithUsers(ctx context.Context, userID uuid.UUID) ([]ListFriendsWithUsersRow, error) {
	rows, err := q.db.Query(ctx, listFriendsWithUsers, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFriendsWithUsersRow{}
	for rows.Next() {
		var i ListFriendsWithUsersRow
		if err := rows.Scan(
			&i.UserID,
			&i.FriendID,
			&i.CreatedAt,
			&i.FriendUserID,
			&i.FriendUsername,
			&i.FriendAvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIncomingRequests = `-- name: ListIncomingRequests :many
SELECT from_user_id, to_user_id, status, message, created_at, responded_at
FROM friend_requests
WHERE to_user_id = $1 AND status = 'pending'
ORDER BY created_at DESC
`

func (q *Queries) ListIncomingRequests(ctx context.Context, toUserID uuid.UUID) ([]FriendRequest, error) {
	rows, err := q.db.Query(ctx, listIncomingRequests, toUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FriendRequest{}
	for rows.Next() {
		var i FriendRequest
		if err := rows.Scan(
			&i.FromUserID,
			&i.ToUserID,
			&i.Status,
			&i.Message,
			&i.CreatedAt,
			&i.RespondedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIncomingRequestsWithUsers = `-- name: ListIncomingRequestsWithUsers :many
SELECT 
    fr.from_user_id,
    fr.to_user_id,
    fr.status,
    fr.message,
    fr.created_at,
    fr.responded_at,
    u.id as from_user_id,
    u.username as from_username,
    u.avatar_url as from_avatar_url
FROM friend_requests fr
INNER JOIN users u ON u.id = fr.from_user_id
WHERE fr.to_user_id = $1 AND fr.status = 'pending'
ORDER BY fr.created_at DESC
`

type ListIncomingRequestsWithUsersRow struct {
	FromUserID    uuid.UUID          `db:"from_user_id" json:"fromUserId"`
	ToUserID      uuid.UUID          `db:"to_user_id" json:"toUserId"`
	Status        string             `db:"status" json:"status"`
	Message       string             `db:"message" json:"message"`
	CreatedAt     pgtype.Timestamptz `db:"created_at" json:"createdAt"`
	RespondedAt   pgtype.Timestamptz `db:"responded_at" json:"respondedAt"`
	FromUserID_2  uuid.UUID          `db:"from_user_id_2" json:"fromUserId2"`
	FromUsername  string             `db:"from_username" json:"fromUsername"`
	FromAvatarUrl pgtype.Text        `db:"from_avatar_url" json:"fromAvatarUrl"`
}

func (q *Queries) ListIncomingRequestsWithUsers(ctx context.Context, toUserID uuid.UUID) ([]ListIncomingRequestsWithUsersRow, error) {
	rows, err := q.db.Query(ctx, listIncomingRequestsWithUsers, toUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListIncomingRequestsWithUsersRow{}
	for rows.Next() {
		var i ListIncomingRequestsWithUsersRow
		if err := rows.Scan(
			&i.FromUserID,
			&i.ToUserID,
			&i.Status,
			&i.Message,
			&i.CreatedAt,
			&i.RespondedAt,
			&i.FromUserID_2,
			&i.FromUsername,
			&i.FromAvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOutgoingRequests = `-- name: ListOutgoingRequests :many
SELECT from_user_id, to_user_id, status, message, created_at, responded_at
FROM friend_requests
WHERE from_user_id = $1 AND status = 'pending'
ORDER BY created_at DESC
`

func (q *Queries) ListOutgoingRequests(ctx context.Context, fromUserID uuid.UUID) ([]FriendRequest, error) {
	rows, err := q.db.Query(ctx, listOutgoingRequests, fromUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FriendRequest{}
	for rows.Next() {
		var i FriendRequest
		if err := rows.Scan(
			&i.FromUserID,
			&i.ToUserID,
			&i.Status,
			&i.Message,
			&i.CreatedAt,
			&i.RespondedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOutgoingRequestsWithUsers = `-- name: ListOutgoingRequestsWithUsers :many
SELECT 
    fr.from_user_id,
    fr.to_user_id,
    fr.status,
    fr.message,
    fr.created_at,
    fr.responded_at,
    u.id as to_user_id,
    u.username as to_username,
    u.avatar_url as to_avatar_url
FROM friend_requests fr
INNER JOIN users u ON u.id = fr.to_user_id
WHERE fr.from_user_id = $1 AND fr.status = 'pending'
ORDER BY fr.created_at DESC
`

type ListOutgoingRequestsWithUsersRow struct {
	FromUserID  uuid.UUID          `db:"from_user_id" json:"fromUserId"`
	ToUserID    uuid.UUID          `db:"to_user_id" json:"toUserId"`
	Status      string             `db:"status" json:"status"`
	Message     string             `db:"message" json:"message"`
	CreatedAt   pgtype.Timestamptz `db:"created_at" json:"createdAt"`
	RespondedAt pgtype.Timestamptz `db:"responded_at" json:"respondedAt"`
	ToUserID_2  uuid.UUID          `db:"to_user_id_2" json:"toUserId2"`
	ToUsername  string             `db:"to_username" json:"toUsername"`
	ToAvatarUrl pgtype.Text        `db:"to_avatar_url" json:"toAvatarUrl"`
}

func (q *Queries) ListOutgoingRequestsWithUsers(ctx context.Context, fromUserID uuid.UUID) ([]ListOutgoingRequestsWithUsersRow, error) {
	rows, err := q.db.Query(ctx, listOutgoingRequestsWithUsers, fromUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOutgoingRequestsWithUsersRow{}
	for rows.Next() {
		var i ListOutgoingRequestsWithUsersRow
		if err := rows.Scan(
			&i.FromUserID,
			&i.ToUserID,
			&i.Status,
			&i.Message,
			&i.CreatedAt,
			&i.RespondedAt,
			&i.ToUserID_2,
			&i.ToUsername,
			&i.ToAvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
