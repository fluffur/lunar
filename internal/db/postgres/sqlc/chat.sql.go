// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: chat.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addUserToChat = `-- name: AddUserToChat :exec
INSERT INTO chat_members (id, chat_id, user_id, joined_at)
VALUES ($1, $2, $3, $4)
ON CONFLICT (chat_id, user_id) DO NOTHING
`

type AddUserToChatParams struct {
	ID       uuid.UUID          `db:"id" json:"id"`
	ChatID   uuid.UUID          `db:"chat_id" json:"chatId"`
	UserID   uuid.UUID          `db:"user_id" json:"userId"`
	JoinedAt pgtype.Timestamptz `db:"joined_at" json:"joinedAt"`
}

func (q *Queries) AddUserToChat(ctx context.Context, arg AddUserToChatParams) error {
	_, err := q.db.Exec(ctx, addUserToChat,
		arg.ID,
		arg.ChatID,
		arg.UserID,
		arg.JoinedAt,
	)
	return err
}

const chatExists = `-- name: ChatExists :one
SELECT EXISTS (SELECT 1
               FROM chats
               WHERE id = $1)
`

func (q *Queries) ChatExists(ctx context.Context, chatID uuid.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, chatExists, chatID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createChat = `-- name: CreateChat :one
INSERT INTO chats (id, name, type, created_at)
VALUES ($1, $2, $3, $4)
RETURNING chats.id
`

type CreateChatParams struct {
	ID        uuid.UUID          `db:"id" json:"id"`
	Name      pgtype.Text        `db:"name" json:"name"`
	Type      string             `db:"type" json:"type"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"createdAt"`
}

func (q *Queries) CreateChat(ctx context.Context, arg CreateChatParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createChat,
		arg.ID,
		arg.Name,
		arg.Type,
		arg.CreatedAt,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getChat = `-- name: GetChat :one
SELECT id, name, type, created_at
FROM chats
WHERE id = $1
`

func (q *Queries) GetChat(ctx context.Context, id uuid.UUID) (Chat, error) {
	row := q.db.QueryRow(ctx, getChat, id)
	var i Chat
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.CreatedAt,
	)
	return i, err
}

const getUserChats = `-- name: GetUserChats :many
SELECT c.id, c.name, c.type, c.created_at
FROM chats c
         JOIN chat_members cm ON cm.chat_id = c.id
WHERE cm.user_id = $1
`

func (q *Queries) GetUserChats(ctx context.Context, userID uuid.UUID) ([]Chat, error) {
	rows, err := q.db.Query(ctx, getUserChats, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Chat{}
	for rows.Next() {
		var i Chat
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isUserChatMember = `-- name: IsUserChatMember :one
SELECT EXISTS (SELECT 1
               FROM chat_members
               WHERE chat_id = $1
                 AND user_id = $2) AS is_member
`

type IsUserChatMemberParams struct {
	ChatID uuid.UUID `db:"chat_id" json:"chatId"`
	UserID uuid.UUID `db:"user_id" json:"userId"`
}

func (q *Queries) IsUserChatMember(ctx context.Context, arg IsUserChatMemberParams) (bool, error) {
	row := q.db.QueryRow(ctx, isUserChatMember, arg.ChatID, arg.UserID)
	var is_member bool
	err := row.Scan(&is_member)
	return is_member, err
}
